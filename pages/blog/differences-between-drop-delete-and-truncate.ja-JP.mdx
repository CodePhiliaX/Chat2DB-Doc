---
title: "SQLにおけるDROP、DELETE、TRUNCATEの違い"
image: ""
description: "データベース操作において、私たちは通常、SQLステートメントを通じてデータベースとやり取りを行います。この記事では、DROP、DELETE、TRUNCATE操作の違いについて詳しく見ていきましょう。"
date: September 12, 2024
---

# SQLにおけるDROP、DELETE、TRUNCATEの違い

データベース操作において、私たちは通常、SQLステートメントを通じてデータベースとやり取りを行います。多くのグラフィカルツールがこれらの作業を簡素化するために利用できますが、最終的には、これらのツールはユーザーのアクションをSQLクエリに変換してデータベースと通信します。どんなに高度なデータベース管理ツールであっても、その基盤は常にSQLに依存しています。

ここでは、現在利用可能な人気のあるグラフィカルデータベースツールをいくつか紹介します：

- **DataGrip**: JetBrainsによって開発され、複数のデータベースに対応し、強力な機能を持つことで開発者の間で広く知られています。
- **DBeaver**: オープンソースのデータベース管理ツールで、DataGripほど知られていませんが、さまざまなデータベースをサポートすることから、開発者コミュニティで人気があります。
- **Navicat**: 20年以上の歴史を持ち、国内市場で高い評価を得ているデータベース管理ツールです。複数のデータベースに対応し、豊富な機能を提供します。
- **Chat2DB**: EasyExcelの創作者であり、元Alibabaの従業員によって設立された新しい製品です。比較的新しい製品ではありますが、AIとの深い統合により、操作効率が大幅に向上し、急速に成長している選択肢です。

優れたデータベースクライアントツールが多数存在する一方で、開発者としてはSQLをしっかり理解し、データベースがどのように動作しているかを知ることが重要です。今日は、`DROP`、`DELETE`、`TRUNCATE`の操作の違いについて詳しく見ていきましょう。

## TL;DR

| 操作      | SQLタイプ                        | 目的                                                            | テーブル構造を保持するか | トランザクションのロールバックをサポートするか | 実行速度                | 使用例                                                       |
| --------- | -------------------------------- | ------------------------------------------------------------ | ------------------------- | ----------------------------- | -------------------------- | ------------------------------------------------------------ |
| DROP      | DDL（データ定義言語）             | テーブルや他のデータベースオブジェクト全体を削除する           | いいえ                     | いいえ                          | 最速                       | テーブルやそのデータが不要になり、完全に削除したい場合。       |
| DELETE    | DML（データ操作言語）             | テーブルから特定のレコード（行）を削除し、テーブル構造とインデックスは保持 | はい                       | はい                           | 遅い（行ごとの削除）         | レコードの一部またはすべてを削除し、テーブル構造を保持したい場合。 |
| TRUNCATE  | DDL（データ定義言語）             | テーブルのすべてのレコードを素早く削除し、テーブル構造とインデックスは保持 | はい                       | いいえ                          | 速い                         | データをすべて削除してもテーブル構造を保持したい場合。          |

## SQLコマンドの種類

DROP、DELETE、TRUNCATEを区別するために、まずそれらをSQLタイプに基づいて分類しましょう。

### DROP

**タイプ**: DDL（データ定義言語）操作。

**構文**: `DROP TABLE table_name;`

**目的**: テーブル、ビュー、インデックス、または他のデータベースオブジェクト全体を削除します。一度実行されると、オブジェクトは復元できず、構造とデータが永久に削除されます。

### DELETE

**タイプ**: DML（データ操作言語）操作。

**構文**: `DELETE FROM table_name WHERE condition;`

**目的**: テーブルから特定のレコード（行）を削除し、テーブル構造とインデックスを保持します。DELETEはWHERE句を使用して条件を指定でき、削除されたレコードはトランザクションのロールバックによって復元可能です（サポートされている場合）。

### TRUNCATE

**タイプ**: DDL操作ですが、主にデータ操作に使用されます。

**構文**: `TRUNCATE TABLE table_name;`

**目的**: テーブル内のすべてのレコードを素早く削除し、テーブル構造とインデックスを保持します。DELETEとは異なり、TRUNCATEはレコード選択のためのWHERE句やトランザクションのロールバックをサポートしません。TRUNCATEは行ごとにレコードを削除するのではなく、テーブルのデータスペースを直接解放するため、通常は高速です。

## パフォーマンス比較

### 1. DROP — 最速

DROP操作は、データベースのメタデータからテーブル全体の定義を削除し、構造、データ、インデックス、トリガーをすべて取り除きます。個々の行を処理するわけではないため、非常に速いです。もう不要なテーブルを完全に削除する場合に適しています。

![Drop操作の時間消費](/image/blog/differences-1-en.png)

### 2. DELETE — 最も遅い

DELETE操作は対象テーブルを行ごとにスキャンし、WHERE句を使用して削除すべき行を決定します。各削除はトランザクションのロールバック目的でログに記録されます。トリガー（BEFORE DELETEやAFTER DELETE）が設定されている場合、削除操作中にトリガーが発火します。この行ごとの処理は、特に複雑なWHERE条件がある場合、DELETEを3つの中で最も遅くします。特定のデータを柔軟に削除する必要がある場合に役立ちます。

![DELETE操作の時間消費](/image/blog/differences-2-en.png)

### 3. TRUNCATE — 速い

TRUNCATE操作はテーブルのデータスペースを直接解放し、行ごとの処理や行レベルのトリガーを発火させることなく、すべてのレコードを削除します。これによりDELETEよりもはるかに高速です。テーブル構造とインデックスは残りますが、DROPほど速くはありません。

![TRUNCATE操作の時間消費](/image/blog/differences-3-en.png)

## DELETEとTRUNCATEの深掘り

### トリガー

#### `DELETE`

削除ログを記録するトリガーを作成し、DELETE操作がトリガーを発動するか確認しましょう。

![delete trigger](/image/blog/differences-4-en.png)

実行後、`delete_log`テーブルには多くの削除ログが含まれていることがわかり、DELETE操作がテーブルに関連するトリガーを発火させることを示しています。

![delete_log](/image/blog/differences-5-en.png)

#### `TRUNCATE`

一方、TRUNCATE操作を使用すると、`delete_log`テーブルには挿入されたログがないことがわかり、TRUNCATE操作は関連するトリガーを発動しないことが確認されます。

![truncate trigger](/image/blog/differences-6-en.png)

### トランザクション

#### `DELETE`

```SQL
-- 現在のレコード数をクエリする関数
SELECT 
  count(*) 
FROM 
  example_data_copy_0902144250 
  ;

SET
  autocommit = 0;

DELETE FROM example_data_copy_0902144250;

-- コミット前に削除を実行した後のレコード数をクエリする
SELECT 
  count(*) 
FROM 
  example_data_copy_0902144250 
  ;

ROLLBACK;

-- トランザクションをロールバックした後のレコード数をクエリする
SELECT 
  count(*) 
FROM 
  example_data_copy_0902144250 
  ;
```

ここでは、上記のSQLを実行した結果を示します：

![result](/image/blog/differences-7-en.png)

3つのクエリ結果を見てみましょう：

![result1](/image/blog/differences-8-en.png)
![result2](/image/blog/differences-9-en.png)
![result3](/image/blog/differences-10-en.png)

上記の画像からわかるように、DELETE操作の前、中、後のテーブルの3つの状態が明確に見て取れます。DELETE操作を実行し、トランザクションをロールバックした後、すべてのデータが元に戻ってくることが確認でき、DELETE操作がトランザクションログリソースを消費していることが証明されます。

#### `TRUNCATE`

```SQL
-- 現在のレコード総数をクエリする関数
SELECT
  count(*)
FROM
  example_data_copy_0902144250;

SET
  autocommit = 0;

TRUNCATE TABLE example_data_copy_0902144250;

-- コミット前にTRUNCATEを実行した後のレコード総数をクエリする
SELECT
  count(*)
FROM
  example_data_copy_0902144250;

ROLLBACK;

-- トランザクションをロールバックした後のレコード総数をクエリする
SELECT
  count(*)
FROM
  example_data_copy_0902144250;
```

ここでは、上記のSQLを実行した結果を示します：

![result](/image/blog/differences-11-en.png)

3つのクエリ結果を見てみましょう：

![result1](/image/blog/differences-12-en.png)
![result2](/image/blog/differences-13-en.png)
![result3](/image/blog/differences-14-en.png)

上記の3つの結果からわかるように、トランザクションがロールバックされるかどうかにかかわらず、TRUNCATE操作を実行した後はデータを復元することはできません。したがって、TRUNCATE操作は不可逆であり、トランザクションログリソースを消費しません。

## まとめ

まとめると、DROP、DELETE、およびTRUNCATEはそれぞれ異なる目的を持ち、データ復元やパフォーマンスに関して異なる影響を与えます。これらの違いを理解することで、特定の状況に応じて適切なコマンドを選択し、データベース管理操作の効率と効果を高めることができます。

## Chat2DB Proを今すぐ始めよう

直感的で強力なAI駆動のデータベース管理ツールをお探しなら、ぜひ **Chat2DB** をお試しください！データベース管理者、開発者、またはデータアナリストの方々に、AIの力で作業をシンプルにします。

**Chat2DB Pro 30日間無料トライアル** をご利用いただき、すべてのプレミアム機能をコミットメントなしで体験してください。Chat2DBがデータベースの管理や操作をどのように変革できるかを実感してください。

👉 [無料トライアルを始める](https://chat2db.ai/pricing) ことで、データベース操作を次のレベルへ！