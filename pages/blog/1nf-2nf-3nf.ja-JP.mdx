---
title: "データベース正規化入門ガイド： 1NF、2NF、3NF、そしてその先へ"
description: "この記事では、正規化の基本的な概念、その重要性、関連するテクニックを探ります。"
image: "/blog/image/17.png"
category: "Guide"
date: October 22, 2024
---

# データベース正規化入門ガイド： 1NF、2NF、3NF、そしてその先へ

この記事では、正規化の基本概念、その重要性、および関連する技術について探求します。この記事は、データ業界に進出したいと考えている読者に適しています。

## SQLにおける正規化とは？

リレーショナルデータベースの文脈において、正規化とはデータ冗長性とその他の異常を排除するためにデータを組織化する方法を指します。簡単に言えば、正規化とは大きな複雑なテーブルを小さな管理しやすいテーブルに分割しつつ、テーブル間のデータ関係を維持することです。このアプローチは特に大規模なデータセットを扱う際、データの一貫性と整合性を確保するために有用です。

正規化がよく使われるいくつかのシナリオを素早く見てみましょう。

![normalization](/image/blog/normalization/1.png)

### データの整合性

顧客情報を保存するデータベースを想像してみてください。正規化がない場合、顧客の年齢が変わったときには、データベース内の複数の場所で更新する必要があり、データの一貫性が損なわれるリスクが高まります。データを正規化することで、一意の識別子を通じて相互に関連付けられた個別のテーブルに情報分割を行うことができ、これによりデータの正確さと一貫性が保証されます。

### 効率的なクエリ

冗長な情報を格納する複数の関連テーブルを持つ複雑なデータベースを考えましょう。この場合、テーブル結合を含むクエリは複雑になるだけでなく、より多くのリソースを消費します。正規化により、データはそれぞれ必要な情報のみを含む小さな専門的なテーブルに分割され、これによりクエリが簡素化され、複雑な結合操作の必要性が減少します。

### ストレージの最適化

冗長データの主な問題の一つは不要なストレージスペースを占有することです。例えば、同じ商品詳細がすべての注文記録に保存されている場合、データが重複します。正規化により、データを異なるテーブルに分割することで、この冗長性を解消することができます。

## なぜSQLの正規化が重要なのか？

正規化はデータベース設計において重要な役割を果たします。以下にその重要性のいくつかの側面を挙げます：

- **冗長性の削減**：冗長性とは、同じ情報を複数回保存することを指します。これを避ける効果的な方法は、データを小さなテーブルに分割することです。
- **クエリパフォーマンスの向上**：正規化後の小さなテーブルは、より高速なクエリ実行をサポートできます。
- **更新異常の最小化**：正規化されたテーブル構造により、他のレコードに影響を与えることなくデータを更新するのが容易になります。
- **データ整合性の向上**：データの一貫性と正確性を確保します。

正規化により、データは効率的に管理および組織化され、データベース全体の品質とパフォーマンスが向上します。

## 正規化が必要となる要因は何ですか？

テーブルが適切に正規化されていない場合、データ冗長が発生し、これはストレージスペースを浪費するとともに、データベースの処理と更新を複雑にします。正規化を必要とする要因は多数ありますが、データ冗長やテーブル間の関係を管理する難しさなどが含まれます。以下に正規化が必要となるいくつかのシナリオを示します：

- 挿入、削除、更新異常：データが適切に管理されていない場合、テーブルへの変更（新しいレコードの挿入、既存データの更新、またはレコードの削除など）はデータエラーまたは不整合につながる可能性があります。これらの異常は予期しないデータの喪失または破損につながるかもしれません。
- 関係の管理の難しさ：非正規化されたデータベース構造では、テーブル間の複雑な関係を維持するのがより困難です。
- その他の推進要因：部分依存と推移的依存も正規化を推進する要因の一つです。部分依存はデータ冗長と更新異常につながり、一方で推移的依存はデータ異常に繋がります。次に、これらの依存関係をどのように処理してデータベースが正規化された状態に到達するかを探ります。

次のセクションでこれらの依存関係をどのように処理するかを見て、データベースが正規化されるようにしましょう。

## データベース正規化の異なる種類

これまで、SQLの正規化が何か、それがなぜ重要なのか、そして正規化を動機づけるさまざまな理由について説明してきました。データベース正規化には異なるレベルがあり、それぞれが異なる程度のデータ組織を表しています。

このセクションでは、これらの異なる正規化レベルを簡単に概観し、次のセクションでさらに詳しく探求します。

![normalization](/image/blog/normalization/2.png)

### 第1正規形 (1NF)

この正規化レベルでは、テーブル内の各列が原子値のみを含むことが保証されています。つまり、列の各エントリは分割不可能です。言い換えれば、スプレッドシートのように、各セルは単一の情報を保持します。1NFはデータの原子性を保証し、各列セルが単一の値のみを含み、各列が一意の名前を持つことを確認します。

### 第2正規形 (2NF)

ここでは、部分依存を排除することでデータがさらに正規化されます。これは、非キーのフィールドがプライマリキー全体ではなく、プライマリキーの一部に完全に依存してはならないことを意味します。つまり、各列は直接プライマリキーに関連しているべきであり、他の非キーのフィールドに対してではありません。

### 第3正規形 (3NF)

このレベルでは、推移的依存がさらに排除されます。これは、プライマリキー以外の非キーのフィールドが他の非キーのフィールドに依存してはならないことを意味します。3NFは2NFに基づいており、より高いデータ整合性を提供します。

### Boyce-Codd正規形 (BCNF)

これは3NFよりも厳格な正規化形式で、他のタイプの異常を解決するために使用されます。BCNFでは、全ての決定要素（すなわち他の列に影響を与える列）は候補キーであるべきです。

### 第4正規形 (4NF)

これはBCNFに基づく正規化レベルで、多重値依存の排除に焦点を当てています。4NFは、プライマリキーに多重値依存を持ちながらプライマリキーの一部ではない列がテーブル内に存在しないことを保証します。

### 第5正規形 (5NF)

5NFは結合依存を解決するための最も高い正規化レベルです。特定の状況下でテーブルをさらに小さなテーブルに分割することによって冗長性を低減するために使用されます。

## 実際の例を使ったデータベース正規化

私たちはデータ正規化のすべてのレベルについて述べました。それらを例と説明とともにさらに詳しく見ていきましょう。

### 第1正規形 (1NF)

1NFは各列セルが単一の原子値のみを含むことを保証します。例えば、図書館のデータベースで、タイトル、著者、カテゴリー、貸出者などの本の情報を保存するテーブルがあるとします。このテーブルが正規化されていない場合、貸出者列（borrowed_by）にはカンマで区切られた複数の貸出者の名前のリストが含まれることがあります。このような状況は1NFの原則に違反しており、単一のセルに複数の値が含まれているからです。以下は先ほど述べた1NFに違反するテーブルの例です。

![normalization](/image/blog/normalization/3.png)

#### 解決策は何ですか？

1NFでは、個別の貸出者テーブルを作成し、それを本テーブルに関連付けることで問題を解決します。テーブル間のリンクを確立するために、貸出者テーブルに本テーブルのプライマリキーを参照する外部キーを追加します。これによりテーブル間の関係が確立され、データの一貫性が保証されます。

以下の図をご覧ください：

**Books table**

![normalization](/image/blog/normalization/4.png)

**Borrowers table**

![normalization](/image/blog/normalization/5.png)

### 第2正規形 (2NF)

前述の通り、この正規化レベルではプライマリキーに対する部分依存が存在しないことを確認することで1NFを基にしています。つまり、全ての非キーのフィールドはプライマリキーの一部ではなく、全体に完全に依存しなければなりません。

すでに1NFが達成されているところから始め、本のテーブルと貸出者のテーブル（1NFセクションで説明したとおり）を持っています。

ここで、これらのテーブルを連結して貸出しを記録したいとしましょう。最初のアプローチとしては、単純に本テーブルにborrower_id列を追加するかもしれません：

![normalization](/image/blog/normalization/6.png)

これは一見解決策のようですが、borrower_idがbook_idに対して部分的にしか依存していないため、2NFに違反しています。本は複数の貸出者を持つことができますが、この構造では単一のborrower_idは1つの本にしかリンクできません。これが部分依存を生じさせます。

#### 解決策は何ですか？

本と貸出者との間に多対多の関係を実装して2NFを達成する必要があります。これは別々のテーブルを導入することで可能です：

**Book_borrowings table**

![normalization](/image/blog/normalization/7.png)

このテーブルは本と貸出者の間の明確な関係を確立します。book_idとborrower_idはそれぞれのテーブルのプライマリキーを参照する外部キーとして機能します。このアプローチにより、borrower_idは本テーブルのプライマリキー（book_id）全体に依存することが保証され、2NFに準拠します。

### 第3正規形 (3NF)

3NFは2NFのさらなる発展で、推移的依存を排除します。推移的依存とは、非キー属性が別の非キー属性に依存し、それがまたプライマリキーに依存するときに形成されます。これは実際には推移的依存の本質を反映しています。

達成した2NFからは、私たちの図書館データベースには以下の3つのテーブルがあります：

**Books table**

![normalization](/image/blog/normalization/8.png)

**Borrowers table**

![normalization](/image/blog/normalization/9.png)

**Book_borrowings table**

![normalization](/image/blog/normalization/10.png)

2NFの構造は効率的のように見えるかもしれませんが、隠れた依存関係を持っているかもしれません。例えば、booksテーブルにdue_date列を追加するとしましょう。一見すると合理的に見えますが、実際にこれは推移的依存を導入します。具体的には：

- due_date列はbook_borrowingsテーブルのborrowing_id（非キー属性）に依存します。
- borrowing_idはbooksテーブルのプライマリキーであるbook_idに依存します。

このように、due_dateは直接book_idに依存せず、borrowing_idという中間の非キー属性を通じて間接的にbook_idに依存しているため、推移的依存となります。

#### 解決策は何ですか？

due_date列を最も適切なテーブルに移動することで、book_borrowingsテーブルにdue_dateとreturned_dateの列を含める形で更新することができます。

以下が更新されたテーブルです：

![normalization](/image/blog/normalization/11.png)

due_date列をbook_borrowingテーブルに配置することで、推移的依存を成功裏に排除しました。

これはdue_dateが今ではbook_idとborrower_idとの複合的な関係に直接依存することを意味します。この文脈では、book_idとborrower_idは複合外部キーとして機能し、それらは共にbook_borrowingsテーブルのプライマリキーを形成します。

### Boyce-Codd正規形 (BCNF)

BCNFは機能的依存に基づいており、関係内のすべての候補キーを考慮しています。機能的依存（FDs）はリレーショナルデータベース内の属性間の関係を定義します。FDsは一つの列の値が別の列の値を決定することを説明します。機能的依存は重要であり、これらの依存関係を特定し、データが適切にテーブル間に分散されるように正規化プロセスをガイドします。

BCNFは3NFよりも厳格な形式です。それはテーブル内の全ての決定要素（すなわち一意に行を識別する属性のセット）が候補キー（すなわち行を一意に識別する最小限の属性のセット）であることを保証します。つまり、全ての決定要素はプライマリキーとして機能できるべきです。

BCNFは、全ての機能的依存（FD）がスーパーキーをその決定要素とするように保証します。つまり、X → Y（すなわちXがYを決定する）のような依存関係がある場合、Xは関係内で候補キー（またはスーパーキー）でなければなりません。ここでXとYはデータテーブルの列を指します。

3NFの構成として、私たちは以下の3つのテーブルを持っています：

**Books table**

![normalization](/image/blog/normalization/12.png)

**Borrowers table**

![normalization](/image/blog/normalization/13.png)

**Book_borrowings table**

![normalization](/image/blog/normalization/14.png)

3NFの構造は一般的には良いですが、book_borrowingsテーブル内に隠れた決定要素があるかもしれません。貸出者が同じ本を同時に一度以上借りられないという前提のもと、book_idとborrower_idの組み合わせは貸出し記録を一意に識別することができます。

この構造はBCNFに違反しており、book_idとborrower_idの組み合わせがテーブルのプライマリキーではなく（実際のプライマリキーはborrowing_idです）。

#### 解決策は何ですか？

BCNFを達成するためには、book_borrowingsテーブルを2つの個別のテーブルに分解するか、属性の組み合わせをプライマリキーとして使用することができます。

アプローチ1（テーブルの分解）

このアプローチでは、book_borrowingsテーブルを2つの個別のテーブルに分割します：

- 一つのテーブルはborrowing_idをプライマリキーとして使用し、borrow_date、due_date、およびreturned_dateを含みます。
- もう一つのテーブルは本と貸出者を関連付けるために使用され、book_idとborrower_idを外部キーとして使用し、特定の貸出しイベントに関連する他の属性を含むかもしれません。

方法2（複合属性セットをプライマリキーとして使用）

別のアプローチとしては、book_idとborrower_idを複合プライマリキーとして使用して各貸出し記録を一意に識別することができます。しかし、このアプローチは制限があり、貸出者が同じ本を複数回借りることができる場合はうまく機能しません。

最終的にどのアプローチを選ぶかは、具体的なデータ要件と貸出し関係をどのようにモデル化したいかによります。

### 第4正規形 (4NF)

多重値依存とは、ある属性が複数の値を持つことができ、それらの値がプライマリキーから独立しているときに発生します。この依存関係はより複雑ですが、例を使って理解しやすくなります。

先ほど他の正規形を説明するために使用した図書館の例は4NFには適用されません。4NFは通常、単一の属性がプライマリキーとは直接関係のない複数の従属属性を持つ可能性がある場合に適用されます。

異なるシナリオを使用してみましょう。出版物に関する情報を保存するデータベースを想像してみてください。このデータベースには「publications」テーブルがあり、Title, Author, Publication Year, Keywords の列があります。

![normalization](/image/blog/normalization/15.png)

上記のテーブル構造は4NFに違反しています：

- keywords列はプライマリキーPublication_idに対して多重値依存を持っています。これは出版物が複数のキーワードを持つことができ、これらのキーワードが出版物の一意の識別子から独立していることを意味します。

#### 解決策は何ですか？

私たちは別のテーブルを作成することができます。

**Publication_keywords table**

![normalization](/image/blog/normalization/16.png)

新たに作成されたテーブル（Publication_keywords）は出版物とキーワードの間の多対多の関係を確立します。各出版物は複数のキーワードを持つことができ、それぞれのキーワードはpublication_id（外部キー）リンクを通じて複数の出版物に関連付けることができます。

これにより、私たちは多重値依存を排除し、4NFを達成しました。

### 第5正規形 (5NF)

5NFは結合依存を排除するための最も複雑な正規化形式です。テーブルがすでに4NFに達していても、特定のクエリを回答するためには複数のテーブルからのデータを結合することが必要になることがあります。

簡単に言えば、5NFは複数のテーブルを結合することで、単一のテーブルで提供されていない追加情報が得られないことを保証します。

テーブルが3NFまたは4NFに正規化されている場合でも、結合依存は比較的少ないため、5NFのための明確かつ単純な例を作成することは相対的に困難です。

しかし、5NFが関連する可能性のあるシナリオを見てみましょう：

大学のデータベースを想定し、「Courses」と「Enrollment」の正規化されたテーブルがあります。

**Courses table**

![normalization](/image/blog/normalization/17.png)

**Enrollments table**

![normalization](/image/blog/normalization/18.png)

テーブルが既に3NFまたは4NFにあると仮定すると、データの保存方法によっては結合依存が存在するかもしれません。例えば、コースの前提条件はCoursesテーブルのPrerequisite_Course_id列として保存されています。

一見するとこれがうまく機能するように見えますが、学生が登録しているコースとそれぞれの前提条件を取得する必要があるクエリを考えると、CoursesとEnrollmentテーブルを結合し、さらにCoursesテーブルを結合して前提条件情報を取得する必要があります。

#### 解決策は何ですか？

潜在的な結合依存を排除し5NFを達成するためには、別のCourse Prerequisitesテーブルを導入することができます：

**Course_prerequisite table**

![normalization](/image/blog/normalization/19.png)

このアプローチは前提条件情報を分離し、「Enrollments」と「Course_precessions」テーブル間の単一の結合で効率的に登録されたコースとその前提条件を取得可能にします。

> 注意：ここでは学生が同一のコースにつき一つの前提条件しか持たないと仮定しています。

5NFは非常に複雑で珍しいタイプの正規化なので、誰かがデータ学習の旅を始めたばかりの時には適用を見つけることはないかもしれませんが、知識を増やし、複雑なデータベースに遭遇したときに備えることができます。

## Chat2DB Proの体験を始めましょう

強力でAIベースのデータベース管理ツールをお探しの方は、ぜひChat2DBをご試用ください！データベース管理者、開発者、データアナリストを問わず、Chat2DBはAIの強力な機能を活用してあなたの仕事を簡略化します。

👉[今すぐChat2DB Proの30日間無料トライアルを体験](https://chat2db.ai/pricing)、全てのプレミアム機能をお楽しみください。
